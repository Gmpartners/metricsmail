const { Email, Account } = require('../models');
const responseUtils = require('../utils/responseUtil');

// Listar emails com informação da conta e suporte a múltiplos filtros
const listEmails = async (req, res) => {
  try {
    const { userId } = req.params;
    const { 
      accountIds, 
      campaignIds, 
      emailIds,
      search,
      limit = 100, 
      page = 1 
    } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Construir filtro base
    const filter = { userId };
    
    // Processar filtro de múltiplas contas
    if (accountIds) {
      const accountIdArray = accountIds.split(',');
      if (accountIdArray.length > 0) {
        filter.account = { $in: accountIdArray };
      }
    }
    
    // Processar filtro de múltiplas campanhas
    if (campaignIds) {
      const campaignIdArray = campaignIds.split(',');
      if (campaignIdArray.length > 0) {
        filter.campaign = { $in: campaignIdArray };
      }
    }
    
    // Processar filtro de múltiplos emails
    if (emailIds) {
      const emailIdArray = emailIds.split(',');
      if (emailIdArray.length > 0) {
        filter._id = { $in: emailIdArray };
      }
    }
    
    // Adicionar filtro de busca por texto
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { subject: { $regex: search, $options: 'i' } },
        { fromName: { $regex: search, $options: 'i' } },
        { fromEmail: { $regex: search, $options: 'i' } }
      ];
    }
    
    // Definir paginação
    const skip = (parseInt(page) - 1) * parseInt(limit);
    const pageSize = parseInt(limit);
    
    // Buscar emails com todas as informações relevantes
    const emails = await Email.find(filter)
      .populate('account', 'name provider')
      .populate('campaign', 'name')
      .sort({ sentDate: -1, createdAt: -1 })
      .skip(skip)
      .limit(pageSize);
    
    // Contar total para paginação
    const totalEmails = await Email.countDocuments(filter);
    
    // Incluir o nome das contas nas métricas para melhor visualização
    const emailsWithAccountInfo = emails.map(email => {
      const emailObj = email.toObject();
      // Garantir que a informação da conta esteja sempre presente
      emailObj.accountName = email.account ? email.account.name : 'Conta Desconhecida';
      emailObj.accountProvider = email.account ? email.account.provider : 'desconhecido';
      
      return emailObj;
    });
    
    // Retornar com informações de paginação
    return responseUtils.success(res, {
      emails: emailsWithAccountInfo,
      pagination: {
        page: parseInt(page),
        pageSize: parseInt(limit),
        totalItems: totalEmails,
        totalPages: Math.ceil(totalEmails / pageSize)
      }
    });
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

// Obter detalhes de um email específico
const getEmailDetails = async (req, res) => {
  try {
    const { userId, emailId } = req.params;
    
    if (!userId || !emailId) {
      return responseUtils.error(res, 'User ID e Email ID são obrigatórios');
    }
    
    // Buscar email com todas as informações relacionadas
    const email = await Email.findOne({
      _id: emailId,
      userId
    })
    .populate('account', 'name provider')
    .populate('campaign', 'name');
    
    if (!email) {
      return responseUtils.notFound(res, 'Email não encontrado');
    }
    
    // Incluir o nome da conta para melhor visualização
    const emailWithAccountInfo = email.toObject();
    emailWithAccountInfo.accountName = email.account ? email.account.name : 'Conta Desconhecida';
    emailWithAccountInfo.accountProvider = email.account ? email.account.provider : 'desconhecido';
    
    return responseUtils.success(res, emailWithAccountInfo);
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

// Comparar múltiplos emails
const compareEmails = async (req, res) => {
  try {
    const { userId } = req.params;
    const { emailIds } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    if (!emailIds) {
      return responseUtils.error(res, 'É necessário fornecer IDs de emails para comparação');
    }
    
    // Processar IDs de emails
    const emailIdArray = emailIds.split(',');
    
    if (emailIdArray.length < 1) {
      return responseUtils.error(res, 'É necessário fornecer pelo menos um email para comparação');
    }
    
    // Buscar emails
    const emails = await Email.find({
      _id: { $in: emailIdArray },
      userId
    })
    .populate('account', 'name provider')
    .populate('campaign', 'name');
    
    if (emails.length === 0) {
      return responseUtils.notFound(res, 'Nenhum email encontrado com os IDs fornecidos');
    }
    
    // Preparar emails com informações da conta para melhor visualização
    const emailsForComparison = emails.map(email => {
      const emailObj = email.toObject();
      
      // Garantir que a informação da conta esteja sempre presente
      emailObj.accountName = email.account ? email.account.name : 'Conta Desconhecida';
      emailObj.accountProvider = email.account ? email.account.provider : 'desconhecido';
      
      // Incluir taxas calculadas se não estiverem presentes
      if (!emailObj.stats || !emailObj.stats.openRate) {
        const m = emailObj.metrics;
        emailObj.stats = {
          openRate: m.deliveredCount > 0 ? (m.uniqueOpenCount / m.deliveredCount) * 100 : 0,
          clickRate: m.deliveredCount > 0 ? (m.uniqueClickCount / m.deliveredCount) * 100 : 0,
          clickToOpenRate: m.uniqueOpenCount > 0 ? (m.uniqueClickCount / m.uniqueOpenCount) * 100 : 0,
          bounceRate: m.sentCount > 0 ? (m.bounceCount / m.sentCount) * 100 : 0,
          unsubscribeRate: m.deliveredCount > 0 ? (m.unsubscribeCount / m.deliveredCount) * 100 : 0,
        };
      }
      
      return emailObj;
    });
    
    // Agrupar emails por conta para melhor visualização
    const emailsByAccount = {};
    
    emailsForComparison.forEach(email => {
      const accountId = email.account ? email.account.id : 'unknown';
      const accountName = email.accountName;
      
      if (!emailsByAccount[accountId]) {
        emailsByAccount[accountId] = {
          accountId,
          accountName,
          accountProvider: email.accountProvider,
          emails: []
        };
      }
      
      emailsByAccount[accountId].emails.push(email);
    });
    
    return responseUtils.success(res, {
      emailsByAccount: Object.values(emailsByAccount),
      emailsForComparison
    });
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

// Listar emails agrupados por conta
const listEmailsByAccount = async (req, res) => {
  try {
    const { userId } = req.params;
    const { search, limit = 100, page = 1 } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Buscar contas primeiro
    const accounts = await Account.find({ userId }).sort({ name: 1 });
    
    if (accounts.length === 0) {
      return responseUtils.success(res, { accounts: [], emailsByAccount: {} });
    }
    
    // Construir filtro base para emails
    const emailFilter = { userId };
    
    // Adicionar filtro de busca por texto se fornecido
    if (search) {
      emailFilter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { subject: { $regex: search, $options: 'i' } },
        { fromName: { $regex: search, $options: 'i' } },
        { fromEmail: { $regex: search, $options: 'i' } }
      ];
    }
    
    // Preparar resultado por conta
    const emailsByAccount = {};
    
    // Inicializar objeto para cada conta
    accounts.forEach(account => {
      emailsByAccount[account._id.toString()] = {
        account: {
          id: account._id,
          name: account.name,
          provider: account.provider,
          status: account.status
        },
        emails: []
      };
    });
    
    // Buscar emails para todas as contas com paginação
    const pageSize = parseInt(limit);
    const skip = (parseInt(page) - 1) * pageSize;
    
    const emails = await Email.find(emailFilter)
      .populate('account', 'name provider')
      .populate('campaign', 'name')
      .sort({ sentDate: -1, createdAt: -1 })
      .skip(skip)
      .limit(pageSize);
    
    // Agrupar emails por conta
    emails.forEach(email => {
      if (email.account) {
        const accountId = email.account._id.toString();
        
        if (emailsByAccount[accountId]) {
          const emailObj = email.toObject();
          emailObj.accountName = email.account.name;
          emailObj.accountProvider = email.account.provider;
          
          emailsByAccount[accountId].emails.push(emailObj);
        }
      }
    });
    
    // Contar total para paginação
    const totalEmails = await Email.countDocuments(emailFilter);
    
    return responseUtils.success(res, {
      accounts: accounts.map(a => ({ 
        id: a._id, 
        name: a.name, 
        provider: a.provider, 
        status: a.status 
      })),
      emailsByAccount,
      pagination: {
        page: parseInt(page),
        pageSize,
        totalItems: totalEmails,
        totalPages: Math.ceil(totalEmails / pageSize)
      }
    });
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

// Exportar métodos
module.exports = {
  listEmails,
  getEmailDetails,
  compareEmails,
  listEmailsByAccount
};
