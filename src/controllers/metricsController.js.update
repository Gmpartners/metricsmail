/**
 * Versão atualizada do controller de métricas para usar os novos campos de ID numéricos
 * em vez de ObjectIds do MongoDB.
 */

const mongoose = require('mongoose');
const { Metrics, Account, Campaign, Event, Email } = require('../models');
const responseUtils = require('../utils/responseUtil');
const dateHelpers = require('../utils/dateHelpersUtil');

/**
 * Obtém métricas agrupadas por dia para um usuário específico
 */
const getMetricsByDate = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, accountId, campaignId, period = 'day' } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Validar datas
    const start = startDate ? new Date(startDate) : dateHelpers.subDays(new Date(), 30);
    const end = endDate ? new Date(endDate) : new Date();
    
    // Validar período
    if (!['day', 'week', 'month'].includes(period)) {
      return responseUtils.error(res, 'Período inválido. Use day, week ou month');
    }
    
    // Filtro base
    const filter = {
      userId,
      date: { $gte: start, $lte: end },
      period
    };
    
    // Aplicar filtros adicionais se fornecidos
    if (accountId) {
      // Verificar se accountId é numérico e converter
      filter.accountID = Number(accountId);
    }
    
    if (campaignId) {
      // Verificar se campaignId é numérico e converter
      filter.campaignID = Number(campaignId);
    }
    
    // Buscar métricas
    const metrics = await Metrics.find(filter)
      .sort({ date: 1 })
      .populate('account', 'name provider accountID')
      .populate('campaign', 'name campaignID');
    
    // Formatar resposta
    const formattedMetrics = metrics.map(metric => {
      const result = {
        date: metric.date,
        metrics: metric.metrics
      };
      
      if (metric.account) {
        result.account = {
          id: metric.accountID,
          name: metric.account.name,
          provider: metric.account.provider
        };
      }
      
      if (metric.campaign) {
        result.campaign = {
          id: metric.campaignID,
          name: metric.campaign.name
        };
      }
      
      return result;
    });
    
    return responseUtils.success(res, formattedMetrics);
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

/**
 * Obtém métricas agrupadas por conta para um usuário específico
 */
const getMetricsByAccount = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, campaignId } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Validar datas
    const start = startDate ? new Date(startDate) : dateHelpers.subDays(new Date(), 30);
    const end = endDate ? new Date(endDate) : new Date();
    
    // Buscar todas as contas do usuário
    const accounts = await Account.find({ userId }).select('_id name provider accountID');
    
    // Resultados por conta
    const results = [];
    
    for (const account of accounts) {
      // Filtro base para métricas desta conta
      const filter = {
        userId,
        accountID: account.accountID,
        date: { $gte: start, $lte: end }
      };
      
      if (campaignId) {
        filter.campaignID = Number(campaignId);
      }
      
      // Buscar métricas desta conta
      const metrics = await Metrics.find(filter);
      
      // Agregação das métricas para esta conta
      const aggregatedMetrics = metrics.reduce((acc, curr) => {
        Object.keys(curr.metrics).forEach(key => {
          // Se for um contador, somamos
          if (key.endsWith('Count') || key === 'totalEvents') {
            acc[key] = (acc[key] || 0) + curr.metrics[key];
          }
          // Se for uma taxa, calculamos a média
          else if (key.endsWith('Rate')) {
            // Armazena os valores para calcular média ponderada depois
            if (!acc[`${key}Values`]) {
              acc[`${key}Values`] = [];
            }
            acc[`${key}Values`].push(curr.metrics[key]);
          }
        });
        return acc;
      }, {});
      
      // Calcular médias para as taxas
      Object.keys(aggregatedMetrics).forEach(key => {
        if (key.endsWith('Values')) {
          const rateKey = key.replace('Values', '');
          // Média simples por enquanto
          const values = aggregatedMetrics[key];
          aggregatedMetrics[rateKey] = values.reduce((sum, val) => sum + val, 0) / values.length;
          // Remover o array de valores
          delete aggregatedMetrics[key];
        }
      });
      
      results.push({
        account: {
          id: account.accountID,
          name: account.name,
          provider: account.provider
        },
        metrics: aggregatedMetrics
      });
    }
    
    return responseUtils.success(res, results);
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

/**
 * Obtém métricas agrupadas por campanha para um usuário específico
 */
const getMetricsByCampaign = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, accountId } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Validar datas
    const start = startDate ? new Date(startDate) : dateHelpers.subDays(new Date(), 30);
    const end = endDate ? new Date(endDate) : new Date();
    
    // Filtro para campanhas
    const campaignFilter = { userId };
    
    if (accountId) {
      campaignFilter.accountID = Number(accountId);
    }
    
    // Buscar todas as campanhas do usuário
    const campaigns = await Campaign.find(campaignFilter)
      .select('_id name account campaignID accountID')
      .populate('account', 'name provider accountID');
    
    // Resultados por campanha
    const results = [];
    
    for (const campaign of campaigns) {
      // Filtro base para métricas desta campanha
      const filter = {
        userId,
        campaignID: campaign.campaignID,
        date: { $gte: start, $lte: end }
      };
      
      // Buscar métricas desta campanha
      const metrics = await Metrics.find(filter);
      
      // Agregação das métricas para esta campanha
      const aggregatedMetrics = metrics.reduce((acc, curr) => {
        Object.keys(curr.metrics).forEach(key => {
          // Se for um contador, somamos
          if (key.endsWith('Count') || key === 'totalEvents') {
            acc[key] = (acc[key] || 0) + curr.metrics[key];
          }
          // Se for uma taxa, calculamos a média
          else if (key.endsWith('Rate')) {
            // Armazena os valores para calcular média ponderada depois
            if (!acc[`${key}Values`]) {
              acc[`${key}Values`] = [];
            }
            acc[`${key}Values`].push(curr.metrics[key]);
          }
        });
        return acc;
      }, {});
      
      // Calcular médias para as taxas
      Object.keys(aggregatedMetrics).forEach(key => {
        if (key.endsWith('Values')) {
          const rateKey = key.replace('Values', '');
          // Média simples por enquanto
          const values = aggregatedMetrics[key];
          aggregatedMetrics[rateKey] = values.reduce((sum, val) => sum + val, 0) / values.length;
          // Remover o array de valores
          delete aggregatedMetrics[key];
        }
      });
      
      results.push({
        campaign: {
          id: campaign.campaignID,
          name: campaign.name
        },
        account: {
          id: campaign.account.accountID,
          name: campaign.account.name,
          provider: campaign.account.provider
        },
        metrics: aggregatedMetrics
      });
    }
    
    return responseUtils.success(res, results);
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

/**
 * Obtém métricas por email para um usuário específico
 */
const getMetricsByEmail = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, accountId, campaignId } = req.query;
    
    if (!userId) {
      return responseUtils.error(res, 'User ID é obrigatório');
    }
    
    // Validar datas
    const start = startDate ? new Date(startDate) : dateHelpers.subDays(new Date(), 30);
    const end = endDate ? new Date(endDate) : new Date();
    
    // Filtro para emails
    const emailFilter = { userId };
    
    if (accountId) {
      // Verificar se a conta pertence ao usuário
      const account = await Account.findOne({ accountID: Number(accountId), userId });
      
      if (!account) {
        return responseUtils.error(res, 'Conta não encontrada ou não pertence ao usuário');
      }
      
      emailFilter.accountID = Number(accountId);
      emailFilter.account = account._id; // Manter para compatibilidade
    }
    
    if (campaignId) {
      try {
        // Buscar campanha usando campaignID em vez de _id
        const campaign = await Campaign.findOne({ campaignID: Number(campaignId) });
        
        if (!campaign) {
          return responseUtils.error(res, "Campanha não encontrada");
        }
        
        // Usar o ObjectId da campanha para relacionamentos internos
        emailFilter.campaign = campaign._id;
        // Armazenar também o campaignID para uso nas APIs
        emailFilter.campaignID = campaign.campaignID;
      } catch (error) {
        console.error('Erro ao buscar campanha:', error);
        return responseUtils.error(res, 'Erro ao processar ID da campanha: ' + error.message);
      }
    }
    
    // Buscar emails do usuário
    const emails = await Email.find(emailFilter)
      .select('_id subject fromName account campaign emailID accountID campaignID');
    
    // Para cada email, buscar seus eventos e calcular as métricas
    const emailMetrics = await Promise.all(
      emails.map(async (email) => {
        const eventFilter = {
          userId,
          email: email._id, // Manter para compatibilidade
          emailID: email.emailID,
          timestamp: { $gte: start, $lte: end }
        };
        
        // Contagens de eventos
        const sentCount = await Event.countDocuments({...eventFilter, eventType: 'send'});
        const deliveredCount = await Event.countDocuments({...eventFilter, eventType: 'delivery'});
        const openCount = await Event.countDocuments({...eventFilter, eventType: 'open'});
        const uniqueOpenCount = await Event.countDocuments({...eventFilter, eventType: 'open', isFirstInteraction: true});
        const clickCount = await Event.countDocuments({...eventFilter, eventType: 'click'});
        const uniqueClickCount = await Event.countDocuments({...eventFilter, eventType: 'click', isFirstInteraction: true});
        const bounceCount = await Event.countDocuments({...eventFilter, eventType: 'bounce'});
        const unsubscribeCount = await Event.countDocuments({...eventFilter, eventType: 'unsubscribe'});
        
        // Cálculo de taxas
        const deliveryRate = sentCount > 0 ? (deliveredCount / sentCount) * 100 : 0;
        const openRate = sentCount > 0 ? (openCount / sentCount) * 100 : 0;
        const uniqueOpenRate = sentCount > 0 ? (uniqueOpenCount / sentCount) * 100 : 0;
        const clickRate = sentCount > 0 ? (clickCount / sentCount) * 100 : 0;
        const uniqueClickRate = sentCount > 0 ? (uniqueClickCount / sentCount) * 100 : 0;
        const clickToOpenRate = uniqueOpenCount > 0 ? (uniqueClickCount / uniqueOpenCount) * 100 : 0;
        const bounceRate = sentCount > 0 ? (bounceCount / sentCount) * 100 : 0;
        const unsubscribeRate = sentCount > 0 ? (unsubscribeCount / sentCount) * 100 : 0;
        
        // Buscar conta e campanha associadas
        const account = await Account.findById(email.account).select('name provider accountID');
        const campaign = await Campaign.findById(email.campaign).select('name campaignID');
        
        return {
          email: {
            id: email.emailID,
            subject: email.subject,
            fromName: email.fromName
          },
          campaign: {
            id: campaign.campaignID,
            name: campaign.name
          },
          account: {
            id: account.accountID,
            name: account.name,
            provider: account.provider
          },
          metrics: {
            sentCount,
            deliveredCount,
            openCount,
            uniqueOpenCount,
            clickCount,
            uniqueClickCount,
            bounceCount,
            unsubscribeCount,
            deliveryRate,
            openRate,
            uniqueOpenRate,
            clickRate,
            uniqueClickRate,
            clickToOpenRate,
            bounceRate,
            unsubscribeRate
          }
        };
      })
    );
    
    return responseUtils.success(res, emailMetrics);
  } catch (err) {
    return responseUtils.serverError(res, err);
  }
};

// Outros métodos seriam atualizados de forma semelhante

// Exportar os métodos do controller
module.exports = {
  getMetricsByDate,
  getMetricsByAccount,
  getMetricsByCampaign,
  getMetricsByEmail,
  // Outros métodos...
};
